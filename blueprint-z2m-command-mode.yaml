blueprint:
  name: "Zigbee2MQTT - MOES Smart Knob COMMAND Mode"
  description: >
    **Version 1.5.3** - All-in-one COMMAND mode controller


    Controls media player volume with intensity-aware rotation and toggles
    home cinema based on JVC projector power state.


    **Features:**

    - Volume scaled by rotation speed (action_step_size)

    - Single press toggles mute

    - Double press toggles play/pause

    - Long press (>3s) toggles cinema ON/OFF based on JVC state

    - Queued mode ensures NO rotation events are dropped


    **No helpers required** - simpler than EVENT mode blueprints.


    **The knob must be in COMMAND mode** (triple-click to switch modes).
    Verify in Z2M: Device → Exposes → operation_mode = "command"


    **Z2M Device Settings (recommended):**

    In Zigbee2MQTT → Device → Settings (gear icon):

    - `debounce`: leave at default (no debounce needed)

    - `filtered_cache`: leave disabled

    - Ensure device has good signal strength (LQI > 50)
  domain: automation
  author: "Jan Singer"
  homeassistant:
    min_version: "2024.6.0"
  input:
    mqtt_settings:
      name: "MQTT Configuration"
      icon: mdi:antenna
      collapsed: false
      description: "Zigbee2MQTT connection settings for the MOES Smart Knob."
      input:
        base_topic:
          name: "Zigbee2MQTT Base Topic"
          description: >
            The base MQTT topic configured in your Zigbee2MQTT settings.
            Default is `zigbee2mqtt` unless you changed it.
          default: "zigbee2mqtt"
          selector:
            text: {}
        mqtt_device_name:
          name: "MQTT Device Friendly Name"
          description: >
            The friendly name of your MOES Smart Knob as configured in
            Zigbee2MQTT (e.g., `Smart Knob`). This is used to
            construct the MQTT topic: `<base_topic>/<friendly_name>`.
          selector:
            text: {}
    media_settings:
      name: "Media Player"
      icon: mdi:speaker
      collapsed: false
      description: "Media players to control. Volume target is required, others are optional overrides."
      input:
        media_player:
          name: "Volume Target (Primary)"
          description: >
            The media player for volume control (rotation).
            Also used as fallback for mute/play if not specified below.
          selector:
            entity:
              filter:
                - domain: media_player
        media_player_mute:
          name: "Mute Target (Optional)"
          description: >
            Override: Media player for mute toggle (single press).
            Leave empty to use the volume target above.
          default: ""
          selector:
            entity:
              filter:
                - domain: media_player
        media_player_play:
          name: "Play/Pause Target (Optional)"
          description: >
            Override: Media player for play/pause (double press).
            Leave empty to use the volume target above.
          default: ""
          selector:
            entity:
              filter:
                - domain: media_player
    cinema_settings:
      name: "Cinema Control"
      icon: mdi:projector
      collapsed: false
      description: "JVC projector sensor and cinema scripts for toggle control."
      input:
        jvc_power_sensor:
          name: "JVC Projector Power Sensor"
          description: >
            The sensor showing JVC projector power state.
            Toggle will turn cinema ON when standby, OFF when on.
            States like warming/cooling/error are ignored.
          selector:
            entity:
              filter:
                - domain: sensor
        cinema_on_script:
          name: "Cinema ON Script"
          description: >
            Script to run when turning the home cinema ON.
          selector:
            entity:
              filter:
                - domain: script
        cinema_off_script:
          name: "Cinema OFF Script"
          description: >
            Script to run when turning the home cinema OFF.
          selector:
            entity:
              filter:
                - domain: script
    timing_settings:
      name: "Timing Settings"
      icon: mdi:timer-outline
      collapsed: true
      description: "Configure double-press detection timing."
      input:
        double_press_delay:
          name: "Double Press Delay (ms)"
          description: >
            Maximum time between two presses to count as double-press.
            Lower = faster response for single press, but harder to double-press.
            Higher = easier double-press, but single press feels delayed.
          default: 250
          selector:
            number:
              min: 100
              max: 500
              step: 50
              unit_of_measurement: "ms"
              mode: slider
    volume_settings:
      name: "Volume Settings"
      icon: mdi:volume-high
      collapsed: true
      description: "Fine-tune volume control behavior."
      input:
        volume_multiplier:
          name: "Volume Multiplier"
          description: >
            Scale factor for volume changes. Higher = more sensitive.
            The knob provides action_step_size (0-255) indicating rotation speed.
            This multiplier adjusts how much volume changes per rotation.
          default: 2
          selector:
            number:
              min: 0.5
              max: 10
              step: 0.5
              mode: slider
        max_volume_step:
          name: "Maximum Volume Step (%)"
          description: >
            Maximum volume change per single rotation event.
            Limits how much a fast rotation can change volume at once.
          default: 10
          selector:
            number:
              min: 1
              max: 20
              step: 1
              unit_of_measurement: "%"
              mode: slider

# Queued mode: ensures NO rotation events are dropped
# Each rotation is processed in order with its own action_step_size
mode: queued
max: 100
max_exceeded: silent

trigger_variables:
  base_topic: !input base_topic
  mqtt_device_name: !input mqtt_device_name

trigger:
  - trigger: mqtt
    topic: "{{ base_topic ~ '/' ~ mqtt_device_name }}"
    qos: 1

# Only process when action field is not empty
condition:
  - "{{ trigger.payload_json.action | default('') != '' }}"

action:
  - variables:
      payload: "{{ trigger.payload_json.action }}"
      # action_step_size: 0-255, but is null for non-rotation actions (toggle, hue_stop)
      # Use default(13, true) to also replace null/None values, not just missing keys
      raw_step: "{{ trigger.payload_json.action_step_size | default(13, true) | int }}"
      step_size: "{{ [raw_step, 13] | max }}"
      # Media player targets (with fallback to primary)
      media_player_id: !input media_player
      media_player_mute_input: !input media_player_mute
      media_player_play_input: !input media_player_play
      mute_target: "{{ media_player_mute_input if media_player_mute_input else media_player_id }}"
      play_target: "{{ media_player_play_input if media_player_play_input else media_player_id }}"
      jvc_sensor_id: !input jvc_power_sensor
      volume_multiplier: !input volume_multiplier
      max_volume_step: !input max_volume_step
      # Calculate step as percentage (0-1 scale)
      # step_size is 13-255, normalize and apply multiplier
      # Formula: (step/255) * (max_step/100) * multiplier
      # With defaults (step=13, max=10%, mult=2): 0.01 = 1% per tick
      step_percent: >-
        {{ (step_size / 255) * (max_volume_step / 100) * volume_multiplier }}
      # Read current volume at execution time (important for queued mode)
      current_vol: "{{ state_attr(media_player_id, 'volume_level') | float(0.5) }}"
      new_vol_up: "{{ [[current_vol + step_percent, 0.0] | max, 1.0] | min }}"
      new_vol_down: "{{ [[current_vol - step_percent, 0.0] | max, 1.0] | min }}"

  - choose:
      # --- Rotate Right: Volume Up ---
      - conditions:
          - "{{ payload == 'brightness_step_up' }}"
        sequence:
          - condition: template
            value_template: "{{ states(media_player_id) not in ['off', 'unavailable', 'unknown'] }}"
          - action: media_player.volume_set
            target:
              entity_id: !input media_player
            data:
              volume_level: "{{ new_vol_up }}"

      # --- Rotate Left: Volume Down ---
      - conditions:
          - "{{ payload == 'brightness_step_down' }}"
        sequence:
          - condition: template
            value_template: "{{ states(media_player_id) not in ['off', 'unavailable', 'unknown'] }}"
          - action: media_player.volume_set
            target:
              entity_id: !input media_player
            data:
              volume_level: "{{ new_vol_down }}"

      # --- Toggle: Single or Double Press detection ---
      - conditions:
          - "{{ payload == 'toggle' }}"
        sequence:
          - variables:
              double_press_delay: !input double_press_delay
              mqtt_topic: "{{ base_topic ~ '/' ~ mqtt_device_name }}"
          # Skip if this is a duplicate toggle from rapid double-click
          # Check both: no other runs active AND not triggered very recently
          # last_triggered is captured BEFORE current trigger updates it, so:
          # - First toggle: last_triggered is old (seconds/minutes ago) → proceed
          # - Second toggle: last_triggered is from first toggle (ms ago) → skip
          - condition: template
            value_template: >-
              {{ this.attributes.current < 1 and
                 (as_timestamp(now()) - as_timestamp(this.attributes.last_triggered)) > 0.3 }}
          # Wait for potential second press
          - wait_for_trigger:
              - trigger: mqtt
                topic: "{{ mqtt_topic }}"
                payload: "toggle"
                value_template: "{{ value_json.action }}"
            timeout:
              milliseconds: "{{ double_press_delay }}"
            continue_on_timeout: true
          - choose:
              # --- Double Press: Play/Pause ---
              - conditions:
                  - "{{ wait.trigger != none }}"
                sequence:
                  - condition: template
                    value_template: "{{ states(play_target) not in ['off', 'unavailable', 'unknown'] }}"
                  - action: media_player.media_play_pause
                    target:
                      entity_id: "{{ play_target }}"
            # --- Single Press: Mute toggle ---
            default:
              - condition: template
                value_template: "{{ states(mute_target) not in ['off', 'unavailable', 'unknown'] }}"
              - action: media_player.volume_mute
                target:
                  entity_id: "{{ mute_target }}"
                data:
                  is_volume_muted: "{{ not state_attr(mute_target, 'is_volume_muted') }}"

      # --- Long Press (>3s): Cinema control based on JVC state ---
      - conditions:
          - "{{ payload == 'hue_move' }}"
        sequence:
          - choose:
              # JVC is ON -> Turn cinema OFF
              - conditions:
                  - "{{ states(jvc_sensor_id) == 'on' }}"
                sequence:
                  - action: script.turn_on
                    target:
                      entity_id: !input cinema_off_script
              # JVC is STANDBY -> Turn cinema ON
              - conditions:
                  - "{{ states(jvc_sensor_id) == 'standby' }}"
                sequence:
                  - action: script.turn_on
                    target:
                      entity_id: !input cinema_on_script
            # Default: do nothing (warming, cooling, error, unavailable)
